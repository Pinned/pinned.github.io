<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    
        <title>在 Android 中使用 Lambda 的原理解析 </title>
        
<link rel="stylesheet" href="/css/toc.css">

    
    <style type="text/css" id="reset">@charset "utf-8";

*,
*::before,
*::after
{
    box-sizing: border-box;
}

body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
figure,
blockquote,
dl,
dd
{
    margin: 0;
}

ul,
ol
{
    list-style: none;
}

ul
{
    padding-inline-start: 0;
}

html,
body
{
    scroll-behavior: smooth;
}

a:not([class])
{
    text-decoration-skip-ink: auto;
}

img,
picture
{
    width: auto;
    max-width: 100%;
    display: block;
}

input,
button,
textarea,
select
{
    font: inherit;
}

@media (prefers-reduced-motion: reduce)
{
    html:focus-within
    {
        scroll-behavior: auto;
    }
}</style>
    <style type="text/css" id="style">@charset "utf-8";

p {
    word-wrap: break-word;
    white-space: pre-wrap;
    text-align: justify;
}

body {
    font-family: "PingFang SC", BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serifhtml, body;
    font-size: 16px;
    line-height: 1.75;
    letter-spacing: 0.6px;
    color: #666;
    background: #F0F0F0;
}

a {
    text-decoration: none;
    color: #000;
}



@media screen and (max-width: 480px) {
    body {
        background: #fff;
    }

    .paper {
        padding: 4vw;
    }

    .paper-main {
        width: 100%;
        margin: 0 auto;
        padding: 30px 1vw 12px;
        background: #fff;
    }
}

@media screen and (min-width: 481px) {
    .paper {
        padding: 4vw;
    }

    .paper-main {
        width: 900px;
        margin: 0 auto;
        padding: 62px 3vw 24px;
        background: #fff;
        border-radius: 24px;
    }
}

.header {
    padding-bottom: 48px;
    margin-bottom: 48px;
    border-bottom: 1px solid #ccc;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-content: center;
}

.logo {
    font-size: 2rem;
    font-weight: 600;
    color: #000;
    margin-bottom: 16px;
    flex: 0 0 100%;
}

.nav {
    margin: 0 0 4px;
    flex: 0 0 100%;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-content: center;
}

.nav li {
    padding: 2px 0;
    margin-right: 24px;
}

.nav li:last-of-type {
    margin-right: 0;
}

.nav li a {
    color: #000;
    opacity: .6;
    transition: opacity ease-in-out .5s;
}

.nav li a:hover {
    opacity: 1;
    transition: opacity ease-in-out .5s;
}

.post-header {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-content: center;
}

.post-header .post-title {
    font-size: 1.375rem;
    display: flex;
    justify-content: center;
    font-weight: bold;
    line-height: 1;
}

.post-list {
    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-items: stretch;
}

.post {
    width: 100%;
    padding-bottom: 48px;
    margin-bottom: 48px;
    border-bottom: 1px dashed #ddd;
}

.post-title {
    display: inline-block;
    font-size: 1.6rem;
    font-weight: 600;
    line-height: 1.5;
    margin-bottom: 12px;
    color: #000;
    /*transition: color ease-in-out .5s;*/
}

.post-title:hover {
    color: #04077e;
    transition: color ease-in-out .5s;
}

.post-except {
    word-break: break-all;
    margin-bottom: 12px;
    text-align: justify;
}

.read-more {
    padding: 0 4px;
    color: #04077e;
}

.read-more:before,
.read-more:after {
    display: inline-block;
    transition: transform ease-in-out .5s;
}

.read-more:before {
    content: "{ ";
}

.read-more:after {
    content: " }";
}

.read-more:hover:before {
    transform: translateX(-4px);
    transition: transform ease-in-out .25s;
}

.read-more:hover:after {
    transform: translateX(4px);
    transition: transform ease-in-out .25s;
}

.post-date {
    font-size: 0.875rem;
    color: #aaa;
}

.paginator {
    font-size: 0.875rem;
    width: 100%;
    margin: 0 auto 24px;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: space-evenly;
    align-items: center;
}

.paginator * {
    display: block;
    padding: 8px 16px;
    border-radius: 18px;
    background: #fff;
    border: 1px solid #eee;
}

.paginator .space {
    display: block;
    padding: 8px 16px;
    border-radius: 18px;
    background: #fff;
    border: none;
}

.paginator a {
    margin: 4px;
    color: #666;
    transition: color ease-in-out .5s;
}

.paginator a:hover {
    color: #04077e;
    transition: color ease-in-out .5s;
}

.paginator .current {
    color: #04077e;
    border: 1px solid #04077e;
}

.footer {
    padding: 24px 0;
    font-size: 0.875rem;
    color: #aaa;
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    justify-content: flex-start;
    align-content: center;
}

.footer span {
    text-align: center;
    margin-bottom: 8px;
}

.footer a {
    color: #aaa;
    transition: color ease-in-out .5s;
}

.footer a:hover {
    color: #04077e;
    transition: color ease-in-out .5s;
}

.post-main {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-items: center;
    margin-bottom: 24px;
}

.post-main-title {
    flex: 0 0 100%;
    margin-bottom: 12px;
    font-size: 1.6rem;
    font-weight: 600;
    line-height: 1.5;
    color: #000;
}

.post-meta {
    font-size: 0.875rem;
    color: #aaa;
    flex: 0 0 100%;
    margin-bottom: 32px;
}

.author {
    color: #576b95;
}

.archive {
    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    justify-content: space-between;
    align-content: normal;
}

.archive li {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    justify-content: flex-start;
    align-content: center;
    padding: 12px 0;
}

.archive li:nth-child(odd) {
    background: #fafafa;
}

.archive li:nth-child(even) {
    background: #fff;
}

.archive li span {
    width: 108px;
    color: #666;
}

.archive-main {
    flex: 0 1 calc(100% - 108px);
}

.archive-title {
    color: #000;
    /*transition: color ease-in-out .5s;*/
}

.archive-title:hover {
    color: #04077e;
    transition: color ease-in-out .5s;
}

.post-image-caption {
    margin-top: 5px;
    text-align: center;
    color: #888;
    font-size: 0.85rem;
    display: block;
}

#clipboardbtn {
    cursor: pointer;
}

#bing-bg {
    width: 100%;
    position: fixed;
    top: 0;
    left: 0;
    z-index: -1;
    filter: blur(10px);
    object-fit: cover;
  }
#go-top {
    cursor: pointer;
}

#beautiful {
    font-family: "PingFang SC", BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serifhtml, body;
    font-size: 16px;
    line-height: 1.75;
    letter-spacing: 0.6px;
}</style>
    <style type="text/css" id="markdown">@charset "utf-8";

#copy-post-content,
#beautiful,
.post-md
{
    width: 100%;
    letter-spacing: 0;
}

.post-md h1,
.post-md h2,
.post-md h3,
.post-md h4,
.post-md h5,
.post-md h6
{
    color: #000;
}
/* 一级标题 */
.post-md h1  {
    display:block;
    border-bottom: 4px solid rgb(33, 33, 34);
    font-size: 1rem;
}
  
/* 一级标题内容 */
.post-md h1  .content {
    display: flex;
    color: rgb(33, 33, 34);
    font-size: 1rem;
}
  
  
/* 一级标题后缀 */
.post-md h1  .suffix {
    display: flex;
    box-sizing: border-box;
    width: 20px;
    height: 10px;
    border-top-left-radius: 20px;
    border-top-right-radius: 20px;
    background: RGBA(33, 33, 34, .5);
    color: rgb(255, 255, 255);
    font-size: 16px;
    letter-spacing: 0.544px;
    justify-content: flex-end;
    box-sizing: border-box !important;
    overflow-wrap: break-word !important;
    float: right;
    margin-top: -10px;
}

/* 二级标题 */
.post-md h2 {
    margin: 10px auto;
    height: 40px;
    background-color: rgb(251, 251, 251);
    border-bottom: 1px solid rgb(246, 246, 246);
    box-sizing: border-box;
    font-size: 1rem;
}

/* 二级标题内容 */
.post-md h2 .content {
    display: inline-block;
    width: auto;
    height: 40px;
    background-color: rgb(33, 33, 34);
    border-bottom-right-radius:100px;
    color: rgb(255, 255, 255);
    padding-right: 30px;
    padding-left: 20px;
    font-size: 1rem;
    line-height: 40px;
}

/* 三级标题 */
.post-md h3 {
    margin: 20px auto 5px;
    border-top: 1px solid rgb(221, 221, 221);
    box-sizing: border-box;
    font-size: 1rem;
}
  
/* 三级标题内容 */
.post-md h3 .content {
    margin-top: -1px;
    padding-top: 6px;
    padding-right: 5px;
    padding-left: 5px;
    font-size: 1rem;
    border-top: 2px solid rgb(33, 33, 34);
    display: inline-block;
    line-height: 1.1;
}
.post-md h4
{
    font-size: 1rem;
    line-height: 1.2;
    padding: 16px 0;
}
.post-md h5
{
    font-size: 0.83rem;
    line-height: 1.2;
    padding: 14px 0;
}
.post-md h6
{
    font-size: 0.67rem;
    line-height: 1.2;
    padding: 12px 0;
}
.post-md a
{
    color: #61aeee;
    box-shadow: 0 2px 0 #ccc;
    transition: color ease-in-out .65s, box-shadow ease-in-out .65s;
}
.post-md a:hover
{
    color: #04077e;
    box-shadow: 0 2px 0 #04077e;
    transition: color ease-in-out .65s, box-shadow ease-in-out .65s;
}
.post-md strong
{
    font-weight: 700;
}
.post-md em
{
    font-style: italic;
}
.post-md kbd
{
    padding: 2px 4px;
    border-radius: 2px;
    background: #eee;
    border: 1px solid #ddd;
}
.post-md ol
{
    list-style: decimal;
    padding-left: 24px;
}
.post-md ul
{
    list-style: disc;
    padding-left: 24px;
}
.post-md img
{
    border-radius: 4px;
}
.post-md hr
{
    border: none;
    height: 1px;
    background: #ccc;
    margin: 24px 0;
}

.post-md p,
.post-md blockquote
{
    width: 100%;
    padding: 7px 0;
}
.post-md blockquote
{
    border-left: 2px solid #ddd;
    padding-left: 12px;
    word-wrap: break-word;
}

.post-md .video-container
{
    background: #000;
    border-radius: 4px;
    overflow: hidden;
}
.post-md iframe,
.post-md .video-container iframe
{
    width: 100%;
    height: 100vh;
    max-height: 360px;
    margin: 12px 0;
}

.post-md table {
    padding: 0;
    word-break: initial;
    width: 100%;
    page-break-inside: auto;
    border-spacing:0px;
    border: 0.5px solid #dfe2e5;
}
.post-md table tr {
    border: 0.5px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
.post-md table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
.post-md table th {
    font-weight: bold;
    border: 0.5px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
.post-md table td {
    border: 0.5px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
.post-md table th:first-child,
.post-md table td:first-child {
    margin-top: 0;
}
.post-md table th:last-child,
.post-md table td:last-child {
    margin-bottom: 0;
}


.inline-code
{
    border-radius: 4px;
    background:rgba(27,31,35,.05);
    padding: 2px 4px;
    color: rgb(0, 112, 96);
    font-size: 1rem;
    margin-left: 1px;
    margin-right: 1px;
}

.post-md .hljs-ln-numbers
{
    opacity: .5;
    padding-right: 12px;
}
</style>
<meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <img id="bing-bg" src="" referrerpolicy="no-referrer" />
        <div class="paper">
            
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4 id="go-top">目录</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1.%20invokedynamic%20%E6%8C%87%E4%BB%A4"><span class="post-toc-text">1. invokedynamic 指令</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2.%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="post-toc-text">2. Lambda 表达式的执行逻辑</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3.%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%84%B1%E7%B3%96%EF%BC%88Desugaring%EF%BC%89"><span class="post-toc-text">3. Lambda 表达式脱糖（Desugaring）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3.1%20LambdaTest.class%20%E8%AF%BB%E5%8F%96"><span class="post-toc-text">3.1 LambdaTest.class 读取</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3.2%20%20LambdaTest$$Lambda$1.class%20%E7%9A%84%E7%94%9F%E6%88%90"><span class="post-toc-text">3.2  LambdaTest$$Lambda$1.class 的生成</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3.3%20%E4%BB%A3%E7%90%86%20dummper"><span class="post-toc-text">3.3 代理 dummper</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3.4%20lambdaFactory$%20%E6%96%B9%E6%B3%95%E7%94%9F%E6%88%90"><span class="post-toc-text">3.4 lambdaFactory$ 方法生成</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3.5%20%E7%BB%93%E6%9E%9C"><span class="post-toc-text">3.5 结果</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4.%20%E6%80%9D%E8%80%83"><span class="post-toc-text">4. 思考</span></a></li></ol>
        </nav>
    </aside>

            <div class="paper-main">
                
                    <div class="post-header">
    <p class="post-title">在 Android 中使用 Lambda 的原理解析</p>
</div>
                
                <div class="post-main">

    
        <div class="post-meta">
            <a class='author' href="/">罗昭成</a> <span id="clipboardbtn">2022年07月20日</span>
        </div>
        <div id="copy-post-content">
            <section id="beautiful">
            <div class="post-md" >
                    <p>Java 在 Android 的发展过程中，扮演了非常重要的角色。在有 Kotlin 之前，开发语言是使用的 Java ，即使现在使用的 Kotlin ， 也是会编译成 Java 的字节码。但受限于 Oracle 的版权，Google 在 Android 上针对 Java 版本的升级，支持的都很不积极。因此，在不同的 Android 版本中，对 JVM 的语法支持不一样？那要如何让高版本的语法，在低版本中的系统中运行呢？ 本文以 Java 8 中的 Lambda 表达式运行在 Android 中的原理，来了解编译过程中的二三事。</p>
<h2 id="1. invokedynamic 指令"><span class="prefix"></span><span class="content">1. invokedynamic 指令</span><span class="suffix"></span></h2><p>在很久很久以前， Java 7 版本发布的时候， JVM 中添加了 <code class="inline-code">invokedynamic</code> 指令， 这条指令用于支持动态语言。在静态类型机制下，方法调用中的类型分析都是在编译时执行的，编译结束就固定下来。而 <code class="inline-code">invokedynamic</code> 允许方法调用可以在运行时指定类和方法，不必在编译的时候确定。在 Java 7 的版本中，我们无法使用 javac 编译出含有 <code class="inline-code">invokedynamic</code> 指令的字节码。而在 Java 8 的版本中，支持的 lambda 表达式就是通过 <code class="inline-code">invokedynamic</code> 关键字来实现的。</p>
<p>为了更好地理解这个指令，我们先来看一下， Java 中另外四个指令</p>
<ul>
<li><code class="inline-code">invokevirtual</code>  用于执行对象实例方法</li>
<li><code class="inline-code">invokestatic</code>  指令用于调用静态方法（即 static 关键字修饰的方法）</li>
<li><code class="inline-code">invokeinterface</code>  该指令用于调用接口方法，在运行时去确定一个实现此接口的对象；</li>
<li><code class="inline-code">invokespecial</code>  该指令用于三种场景：调用实例构造方法，调用私有方法（即 private关键字修饰的方法）和父类方法（即 super 关键字调用的方法）</li>
</ul>
<p>先看个例子：</p>
<pre><code class="java">import java.util.*;

class JvmInstruction &#123;
    public static void main(String[] args) &#123;
        JvmInstruction.run();
    &#125;
    
    public static void run() &#123;
        JvmInstruction instruction = new JvmInstruction();
        instruction.start();
    &#125;
    
    public void start() &#123;
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;List&quot;);
        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();
        arrayList.add(&quot;ArrayList&quot;);
    &#125;
&#125;
</code></pre>
<p>代码很简单，此处重点看一下编译生成的 <code class="inline-code">CLASS</code> 文件的格式， 通过命令可以输出方法以及方法调用指令， 命令如下：</p>
<pre><code class="shell">javap -c -p JvmInstruction
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/969bbfb8a2314d498083188ce3be6257.png" alt="JvmInstruction 中方法列表及调用栈信息" referrerpolicy="no-referrer"></p>
<p>从上面的截图中，可以看到：</p>
<ol>
<li>代码中的 <code class="inline-code">JvmInstruction.run();</code> 编译后变成图中 11 行的 <code class="inline-code">invokestatic #2</code>。</li>
<li>代码中的 <code class="inline-code">instruction.start();</code> 编译后变成图中 21 行的 <code class="inline-code">invokevirtual #5</code></li>
<li>代码中的 <code class="inline-code">list.add(&quot;List&quot;);</code> 编译后变成图中 32 行的 <code class="inline-code">invokeinterface #9, 2</code></li>
<li>代码中的 <code class="inline-code">new JvmInstruction();</code> 编译后变成图中 18 行的 <code class="inline-code">invokespecial #4</code></li>
</ol>
<p>通过上面的分析，相信都能理解这几条指令的静态类型。那关于 <code class="inline-code">invokedynamic</code> 的动态调用是什么意思呢？ </p>
<p>在 <code class="inline-code">invokedynamic</code> 指令执行中，会先找到 Bootstrap method (BSM) ，使用 <code class="inline-code">invokestatic</code> 的指令，获取到真实<strong>CallSite（调用点）</strong>，JVM 会直接调用 <code class="inline-code">CallSite</code> 中绑定的 <strong>MethodHandle(方法句柄)</strong> 执行真实的逻辑。整个过程有点类似于反射。在 JVM 虚拟机中，CallSite 被抽象成了一个 Java 的类。如果想了解其实现原码，也可以参考 JDK 里 <strong>rt.jar</strong> 中对应的类。</p>
<h2 id="2. Lambda 表达式的执行逻辑"><span class="prefix"></span><span class="content">2. Lambda 表达式的执行逻辑</span><span class="suffix"></span></h2><p>为了更好的理解 <code class="inline-code">invokedynamic</code> 的执行，此处以 JAVA 8 支持的 Lambda 表达式为例，为减少内容，本例中使用了最简单的例子，先上代码： </p>
<pre><code class="java">class LambdaTest &#123;
    public static void main(String[] args) &#123;
        Runnable runable = () -&gt; System.out.println(&quot;test&quot;);
        runable.run();
    &#125;
&#125;
</code></pre>
<p>在代码中的第三行，使用了 lambda 表达式定义了一个 Runnable 对象。编译执行会输出 <code class="inline-code">test</code> 。</p>
<p>先看一下编译后的 class 文件中的内容，使用如下命令：</p>
<pre><code class="shell">javap -c -p LambdaTest
</code></pre>
<p>得到如下结果：</p>
<p><img src="https://img-blog.csdnimg.cn/f54ea5042f364961b949bc428a91618f.png" alt="CLASS 中的方法列表" referrerpolicy="no-referrer"></p>
<p>在上述代码与编译后的字节码中，我们可以看到，代码中的 lambda 表达式变成了字节码中的 <code class="inline-code">11</code> 行，即 <code class="inline-code">0: invokedynamic #2,  0</code>。当然，从这个字节码中，可以看到，除了代码中写的 <code class="inline-code">main</code> 方法，<code class="inline-code">System.out.println(&quot;test&quot;)</code> 被放到了 <code class="inline-code">lambda$main$0()</code> 这个私有的静态方法中去了。</p>
<p>为了更好的看清楚 <code class="inline-code">invokedynamic</code> 的执行逻辑，可以通过：</p>
<pre><code class="shell">javap -v LambdaTest
</code></pre>
<p>输出CLASS 文件中的常量池等信息，因文件里面的内容信息较多，省略了一些不需要关注的点，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/c3a95e1118d7495ea86f888364c62f9a.png" alt="CLASS 详细信息" referrerpolicy="no-referrer"></p>
<p>根据上面的信息，可以看到，整个逻辑如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/a0a28f6ffd564c1c8d513e233561b6a5.png" alt="Lambda 表达式的整个过程 " referrerpolicy="no-referrer"></p>
<p>如前文所示，在执行 <code class="inline-code">InvokeDynamic</code> 指令会调用 BootstapMethods，返回一个 CallSite 对象，对应代码在 rt.jar 中。</p>
<blockquote>
<p>PS: BootstapMethods 中，第一次执行时，会生成 <code class="inline-code">LambdaTest$$Lambda$1</code> 的 class，可以通过参数  <strong>-Djdk.internal.lambda.dumpProxyClasses</strong> 将生成的 class 缓存下来。</p>
</blockquote>
<p>有了整体概括，再来看一下 BootstapMethod 里面的源码逻辑：</p>
<ol>
<li>invokestatic 调用 LambdaMetafactory 中的 metafactory 方法</li>
</ol>
<pre><code class="java">public static CallSite metafactory(MethodHandles.Lookup caller,
                                   String invokedName,
                                   MethodType invokedType,
                                   MethodType samMethodType,
                                   MethodHandle implMethod,
                                   MethodType instantiatedMethodType)
  throws LambdaConversionException &#123;
  AbstractValidatingLambdaMetafactory mf;
  // 通过传入的参数去创建 factory
  mf = new InnerClassLambdaMetafactory(caller, invokedType,
                                       invokedName, samMethodType,
                                       implMethod, instantiatedMethodType,
                                       false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);
  mf.validateMetafactoryArgs();
  // 返回 JVM invokedymaic 需要的 CallSite
  return mf.buildCallSite();
&#125;
</code></pre>
<ol start="2">
<li>InnerClassLambdaMetafactory 的初始化过程</li>
</ol>
<pre><code class="java">public InnerClassLambdaMetafactory(MethodHandles.Lookup caller,
                                   MethodType invokedType,
                                   String samMethodName,
                                   MethodType samMethodType,
                                   MethodHandle implMethod,
                                   MethodType instantiatedMethodType,
                                   boolean isSerializable,
                                   Class&lt;?&gt;[] markerInterfaces,
                                   MethodType[] additionalBridges)
  throws LambdaConversionException &#123;
  super(caller, invokedType, samMethodName, samMethodType,
        implMethod, instantiatedMethodType,
        isSerializable, markerInterfaces, additionalBridges);
  implMethodClassName = implDefiningClass.getName().replace(&#39;.&#39;, &#39;/&#39;);
  implMethodName = implInfo.getName();
  implMethodDesc = implMethodType.toMethodDescriptorString();
  implMethodReturnClass = (implKind == MethodHandleInfo.REF_newInvokeSpecial)
    ? implDefiningClass
    : implMethodType.returnType();
  constructorType = invokedType.changeReturnType(Void.TYPE);
  // 拿到要生成的 lambdaClassName, 即本例中的 LambdaTest$$Lambda$1
  lambdaClassName = targetClass.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$Lambda$&quot; + counter.incrementAndGet();
  // 使用 ClassWriter 生成最后的 class 文件
  cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
  int parameterCount = invokedType.parameterCount();
  if (parameterCount &gt; 0) &#123;
    argNames = new String[parameterCount];
    argDescs = new String[parameterCount];
    for (int i = 0; i &lt; parameterCount; i++) &#123;
      argNames[i] = &quot;arg$&quot; + (i + 1);
      argDescs[i] = BytecodeDescriptor.unparse(invokedType.parameterType(i));
    &#125;
  &#125; else &#123;
    argNames = argDescs = EMPTY_STRING_ARRAY;
  &#125;
&#125;
</code></pre>
<p>因此， <code class="inline-code">runable.run();</code> 相当于调用了 <code class="inline-code">LambdaTest$$Lambda$1().run()</code>，而在生成的这个 <code class="inline-code">class</code> 文件中，又调用了 <code class="inline-code">LambdaTest.lambda$main$0()</code>。</p>
<h2 id="3. Lambda 表达式脱糖（Desugaring）"><span class="prefix"></span><span class="content">3. Lambda 表达式脱糖（Desugaring）</span><span class="suffix"></span></h2><p>前面讲到了 Lambda 在高版本 JVM 中，使用 InvokeDynamic 指令，得以在运行时，执行 Lambda 表达式，那针对 Android 来讲，低版本 Android OS 无法执行，要怎么样处理呢？答案是脱糖。</p>
<p><img src="https://img-blog.csdnimg.cn/e308940a26dc4d00b5c2b4ede7191d1b.png" alt="Android 中 Java 文件变成 Dex 的过程" referrerpolicy="no-referrer"></p>
<p>在 D8&#x2F;R8 中，进行了 class 文件到 Dex 文件的优化，并且在这一步完成了脱糖。脱糖的实现思路是什么样子的？ 本文以开源库的 retrolambda 为例分析，脱糖的过程。</p>
<blockquote>
<p>PS： R8 将 Proguard 整合，故没有单独的 Proguard 流程。</p>
</blockquote>
<p>从前面的内容中，我们知道 Lambda 在执行中，使用的是 <code class="inline-code">invokedynamic</code> 来实现的，要在低版本中执行，那就需要把这个指令换成低版本 JVM 支持的指令。在前文提到， Lambda 表达式，在运行的时候，会动态生成 <code class="inline-code">LambdaTest$$Lambda$1.class</code> ， 在脱糖的过程中，将动态生成的逻辑，前置到编译时完成即可。</p>
<h3 id="3.1 LambdaTest.class 读取"><span class="prefix"></span><span class="content">3.1 LambdaTest.class 读取</span><span class="suffix"></span></h3><p>为了方便读取 Class 文件的内容，在 <code class="inline-code">retrolambda</code> 库中使用了 <code class="inline-code">org.ow2.asm:asm-all:5.2</code> 进行 Class 读取与生成。 有关 asm 的使用，可以参考其官方文档，此处不进行讨论。</p>
<p>使用 ASM 遍历现有的 class 文件，找到方法中，使用了 invokedynamic 的位置，此处使用的是BSM来查找的，Lambda 表达式编译后，使用的是 <code class="inline-code">java/lang/invoke/LambdaMetafactory</code>，处理代码逻辑如下：</p>
<pre><code class="java">@Override
public void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) &#123;
  // 此处找到 BSM 为 LambdaMetafactory 的调用点，将此处的调用使用我们生成的代码进行替换。
  if (bsm.getOwner().equals(&quot;java/lang/invoke/LambdaMetafactory&quot;)) &#123;
    backportLambda(name, Type.getType(desc), bsm, bsmArgs);
  &#125; else &#123;
    super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);
  &#125;
&#125;

private void backportLambda(String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) &#123;
  Class&lt;?&gt; invoker = loadClass(className);
  Handle implMethod = (Handle) bsmArgs[1];
  Handle accessMethod = implMethod;
  EnclosingClass enclosingClass = new EnclosingClass();
  enclosingClass.sourceFile = source;
  // 获取生成的Lambda 的class 名： LambdaTest$$Lambda$1, 方法为固定的 lambdaFactory$
  LambdaFactoryMethod factory = LambdaReifier.reifyLambdaClass(enclosingClass, implMethod, accessMethod,
                                                               invoker, invokedName, invokedType, bsm, bsmArgs);
  // invokestatic  #19  // Method LambdaTest$$Lambda$1.lambdaFactory$:()Ljava/lang/Runnable;
  super.visitMethodInsn(INVOKESTATIC, factory.getOwner(), factory.getName(), factory.getDesc(), false);
&#125;
</code></pre>
<h3 id="3.2  LambdaTest$$Lambda$1.class 的生成"><span class="prefix"></span><span class="content">3.2  LambdaTest$$Lambda$1.class 的生成</span><span class="suffix"></span></h3><p>在前面的 lambda 执行的流程中，可以在运行时添加 jvm 参数 <code class="inline-code">-Djdk.internal.lambda.dumpProxyClasses</code> 来生成 LambdaTest$$Lambda$1.class 文件。因此，在脱糖的过程中，也可以使用它来实现 class 文件生成。</p>
<p>在步骤 1 中，通过遍历所有的 method 的内容，查找到 <strong>LambdaMetafactory</strong> 的调用点，这个时候，可以模拟调用 LambdaMetafactory， 代码实现如下： </p>
<pre><code class="java">// 此处的 bsm 就是 class 文件中， bootstrap 中定义的那个 bsm
private static CallSite callBootstrapMethod(Class&lt;?&gt; invoker, String invokedName, Type invokedType, Handle bsm, Object[] bsmArgs) throws Throwable &#123;
  ClassLoader cl = invoker.getClassLoader();
  MethodHandles.Lookup caller = getLookup(invoker);

  List&lt;Object&gt; args = new ArrayList&lt;&gt;();
  args.add(caller);
  args.add(invokedName);
  args.add(toMethodType(invokedType, cl));
  for (Object arg : bsmArgs) &#123;
    args.add(asmToJdkType(arg, cl, caller));
  &#125;

  MethodHandle bootstrapMethod = toMethodHandle(bsm, cl, caller);
  // 使用 MethodHandle 模拟调用，会触发 class 文件生成。
  return (CallSite) bootstrapMethod.invokeWithArguments(args);
&#125;
</code></pre>
<h3 id="3.3 代理 dummper"><span class="prefix"></span><span class="content">3.3 代理 dummper</span><span class="suffix"></span></h3><p>JVM 运行时使用的是 InnerClassLambdaMetafactory 进行类生成的，可以通过反射，修改实例变量  <code class="inline-code">dumper</code> 来实现缓存生成的 Class 文件。实现代码如下：</p>
<pre><code class="java">public void install() &#123;
  try &#123;
    Class&lt;?&gt; mf = Class.forName(&quot;java.lang.invoke.InnerClassLambdaMetafactory&quot;);
    dumperField = mf.getDeclaredField(&quot;dumper&quot;);
    makeNonFinal(dumperField);
    dumperField.setAccessible(true);

    Path p = new VirtualPath(&quot;&quot;);
    dumperField.set(null, newProxyClassesDumper(p));
  &#125; catch (Exception e) &#123;
    throw new IllegalStateException(&quot;Cannot initialize dumper; unexpected JDK implementation. &quot; +
                                    &quot;Please run Retrolambda using the Java agent (enable forking in the Maven plugin).&quot;, e);
  &#125;
&#125;
</code></pre>
<h3 id="3.4 lambdaFactory$ 方法生成"><span class="prefix"></span><span class="content">3.4 lambdaFactory$ 方法生成</span><span class="suffix"></span></h3><p>读取第 3 步产生的 class 文件，并为其添加 instance 实例以及 factory method ， 生成代码类似： </p>
<pre><code class="java">// 需要添加的实例
private static final LambdaTest$$Lambda$1 instance = new LambdaTest$$Lambda$1();
// factory 方法。
public static Runnable lambdaFactory$() &#123;
  return instance;
&#125;
</code></pre>
<p>在 <code class="inline-code">visitEnd</code> 的时候，添加 <code class="inline-code">instance</code> 以及 <code class="inline-code">lambdaFactory$</code>方法到 class 文件中，实现代码如下：</p>
<pre><code class="java">@Override
public void visitEnd() &#123;
  makeSingleton();
  generateFactoryMethod();
  if (sourceFile == null) &#123;
    sourceFile = enclosingClass.sourceFile;
  &#125;
  super.visitSource(sourceFile, sourceDebug);
  super.visitEnd();
&#125;

private void makeSingleton() &#123;
  FieldVisitor fv = super.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL,
                                     SINGLETON_FIELD_NAME, singletonFieldDesc(), null, null);
  fv.visitEnd();

  MethodVisitor mv = super.visitMethod(ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);
  mv.visitCode();
  mv.visitTypeInsn(NEW, lambdaClass);
  mv.visitInsn(DUP);
  mv.visitMethodInsn(INVOKESPECIAL, lambdaClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
  mv.visitFieldInsn(PUTSTATIC, lambdaClass, SINGLETON_FIELD_NAME, singletonFieldDesc());
  mv.visitInsn(RETURN);
  mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS
  mv.visitEnd();
&#125;

private void generateFactoryMethod() &#123;
  MethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC,
                                    factoryMethod.getName(), factoryMethod.getDesc(), null, null);
  mv.visitCode();
  mv.visitFieldInsn(GETSTATIC, lambdaClass, SINGLETON_FIELD_NAME, singletonFieldDesc());
  mv.visitInsn(ARETURN);
  mv.visitMaxs(-1, -1); // rely on ClassWriter.COMPUTE_MAXS
  mv.visitEnd();
&#125;
</code></pre>
<h3 id="3.5 结果"><span class="prefix"></span><span class="content">3.5 结果</span><span class="suffix"></span></h3><p>为了更清晰地理解结果，此处使用 <code class="inline-code">java -c -p </code> 将 class 文件中所有的方法都打印出来，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/b68bfa4e3a1b4c3b8b61fdad736eff12.png" alt="脱糖后的 LambdaTest.class" referrerpolicy="no-referrer"></p>
<p><img src="https://img-blog.csdnimg.cn/855cad054761409fa063dc903bc4b1ff.png" alt="生成的 LabdaTest$$Lambda$1.class" referrerpolicy="no-referrer"></p>
<h2 id="4. 思考"><span class="prefix"></span><span class="content">4. 思考</span><span class="suffix"></span></h2><p>有了上面的脱糖流程，既然可以在编译时，就能实现 lambda 的逻辑，为什么还要添加 <code class="inline-code">invokedynamic</code> 指令呢？ 这不得不提 Java 是一种静态类型语言，所有的东西都是在编译时都已经确定好了，静态类型的语言在运行相对效率更高，但灵活性就有所降低。而 <code class="inline-code">invokedynamic</code> 的设计就是让 JVM 可以更加的灵活，让基于 JVM 的语言设计者，可以有更多的自由度。</p>

                    <hr/>
            </div>
            </section>
        </div>
        <div style="margin: auto;">
            <div>
                <img src="https://moe-counter.glitch.me/get/@pinned_blog_在 Android 中使用 Lambda 的原理解析?theme=moebooru" style="margin: 0 auto;" referrerpolicy="no-referrer">
            </div>
        </div>
        <input id="copy-input" style="position: absolute; left: -1000px; z-index: -1000;">

    

</div>
                <!-- 
                    <div class="post_pre_next">
    
        <div class="post-pre">
            <a href="/2022/08/20/iterm2-configuration/">上一篇: iTerm2 常用配置</a>
        </div>
    
    
        <a href="/2022/07/04/Java-Base64/">下一篇: 
            干货，深度解析 Base64 !
        </a>
    
</div>


                 -->
                <div class="footer">
    <span>Copyright © 2023 大罗说事</span>
</div>

<!-- 
<link rel="stylesheet" href="/css/highlight.default.css">
 -->
<style type="text/css" id="atom-one-dark">pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 12px;
  font-size: 12px;
}
/*

Atom One Dark by Daniel Gamage
Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

base:    #282c34
mono-1:  #abb2bf
mono-2:  #818896
mono-3:  #5c6370
hue-1:   #56b6c2
hue-2:   #61aeee
hue-3:   #c678dd
hue-4:   #98c379
hue-5:   #e06c75
hue-5-2: #be5046
hue-6:   #d19a66
hue-6-2: #e6c07b

*/

.hljs {
  color: #abb2bf;
  background: #282c34;
}

.hljs-comment,
.hljs-quote {
  color: #5c6370;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #c678dd;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e06c75;
}

.hljs-literal {
  color: #56b6c2;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta .hljs-string {
  color: #98c379;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #d19a66;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #61aeee;
}

.hljs-built_in,
.hljs-title.class_,
.hljs-class .hljs-title {
  color: #e6c07b;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}

</style>
<style type="text/css" id="code-theme">pre::before {
    content: '';
    display: block;
    background: url("http://pinned.github.io/img/mac_style.svg");
    height: 30px;
    width: 100%;
    background-size: 40px;
    background-repeat: no-repeat;
    background-color: #282c34;
    margin-bottom: -7px;
    border-radius: 5px;
    background-position: 10px 10px;
}

pre code {
    border-radius: 5px;
}</style>

<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script src="/js/juice.js"></script>


<script src="/js/copy_wechat.js"></script>


<script>
    hljs.highlightAll();
    // window.onload = function() {
    //     // 判断是否为手机浏览器
    //     const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

    //     if (!isMobile) {
    //         fetch('https://pinned.github.io/bing-daily-picture/index.json')
    //             .then(response => response.text())
    //             .then(data => {
    //                 var result = JSON.parse(data)
    //                 var count = result.images.length
    //                 const index = Math.floor(Math.random() * count);
    //                 document.getElementById("bing-bg").src = "https://cn.bing.com" + result.images[index].url;
    //             }); // 返回的结果
    //     } 
    // }    
</script>

            </div>
        </div>
    </body>
</html>