<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>大罗说事 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <p class="post-title">Android加载子View</p>
</div>
                
                <div class="post-main">

    
        <div class="post-meta">
            <a class='author' href="/">罗昭成</a> 2023年05月29日
        </div>
        <div class="post-md">
            <p>Android的一个View界面都是通过ViewGroup 加上很多子View来实现的，即<code>viewGroup.addView(view)</code>。</p>
<p>让我一起来看看源码是如何执行的。</p>
<p><strong>addView(view)</strong></p>
<pre><code class="java">public void addView(View child) &#123;
    addView(child, -1);
&#125;
public void addView(View child, int index) &#123;
    if (child == null) &#123;
        throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;);
    &#125;
    LayoutParams params = child.getLayoutParams();
    if (params == null) &#123;
        params = generateDefaultLayoutParams();
        if (params == null) &#123;
            throw new IllegalArgumentException(&quot;generateDefaultLayoutParams() cannot return null&quot;);
        &#125;
    &#125;
    addView(child, index, params);
&#125;
</code></pre>
<p>从上面的代码可以看出，如果我们直接执行的<code>addView</code>将会设置默认<code>index</code>为 -1。然后读取子View的<code>LayoutParams</code>。如果子View没有设置相应的LayoutParams,则生成一个默认的LayoutParams来使用</p>
<p>接着往下面看：</p>
<pre><code class="java">public void addView(View child, int index, LayoutParams params) &#123;
    if (DBG) &#123;
        System.out.println(this + &quot; addView&quot;);
    &#125;

    if (child == null) &#123;
        throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;);
    &#125;

    // addViewInner() will call child.requestLayout() when setting the new LayoutParams
    // therefore, we call requestLayout() on ourselves before, so that the child&#39;s request
    // will be blocked at our level
    requestLayout();
    invalidate(true);
    addViewInner(child, index, params, false);
&#125;
private void addViewInner(View child, int index, LayoutParams params,
        boolean preventRequestLayout) &#123;

    if (mTransition != null) &#123;
        // Don&#39;t prevent other add transitions from completing, but cancel remove
        // transitions to let them complete the process before we add to the container
        mTransition.cancel(LayoutTransition.DISAPPEARING);
    &#125;

    if (child.getParent() != null) &#123;
        throw new IllegalStateException(&quot;The specified child already has a parent. &quot; +
                &quot;You must call removeView() on the child&#39;s parent first.&quot;);
    &#125;

    if (mTransition != null) &#123;
        mTransition.addChild(this, child);
    &#125;

    if (!checkLayoutParams(params)) &#123;
        params = generateLayoutParams(params);
    &#125;

    if (preventRequestLayout) &#123;
        child.mLayoutParams = params;
    &#125; else &#123;
        child.setLayoutParams(params);
    &#125;

    if (index &lt; 0) &#123;
        index = mChildrenCount;
    &#125;

    addInArray(child, index);

    // tell our children
    if (preventRequestLayout) &#123;
        child.assignParent(this);
    &#125; else &#123;
        child.mParent = this;
    &#125;

    if (child.hasFocus()) &#123;
        requestChildFocus(child, child.findFocus());
    &#125;

    AttachInfo ai = mAttachInfo;
    if (ai != null &amp;&amp; (mGroupFlags &amp; FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW) == 0) &#123;
        boolean lastKeepOn = ai.mKeepScreenOn;
        ai.mKeepScreenOn = false;
        child.dispatchAttachedToWindow(mAttachInfo, (mViewFlags&amp;VISIBILITY_MASK));
        if (ai.mKeepScreenOn) &#123;
            needGlobalAttributesUpdate(true);
        &#125;
        ai.mKeepScreenOn = lastKeepOn;
    &#125;

    if (child.isLayoutDirectionInherited()) &#123;
        child.resetRtlProperties();
    &#125;

    onViewAdded(child);

    if ((child.mViewFlags &amp; DUPLICATE_PARENT_STATE) == DUPLICATE_PARENT_STATE) &#123;
        mGroupFlags |= FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE;
    &#125;

    if (child.hasTransientState()) &#123;
        childHasTransientStateChanged(child, true);
    &#125;

    if (child.getVisibility() != View.GONE) &#123;
        notifySubtreeAccessibilityStateChangedIfNeeded();
    &#125;
&#125;
</code></pre>
<p>就是如此的Easy，就把View添加到视图中去了。</p>

        </div>

    

</div>
                <!-- 
                    <div class="post_pre_next">
    
        <div class="post-pre">
            <a href="/2023/05/29/2015-05-25-android-soft-keyboard/">上一篇: 【转】Android打开与关闭软键盘</a>
        </div>
    
    
        <a href="/2023/05/29/2015-07-28-xml-listview-divider-margin/">下一篇: 
            XML 实现 ListView divider margin
        </a>
    
</div>


                 -->
                <div class="footer">
    <span>Copyright © 2023 大罗说事</span>
</div>

<!-- 
<link rel="stylesheet" href="/css/highlight.default.css">
 -->

<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/code-theme.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
    hljs.highlightAll();
</script>

            </div>
        </div>
    </body>
</html>